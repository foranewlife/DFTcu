# Performance Hints

**Jeff Dean, Sanjay Ghemawat**

*Original version: 2023/07/27, last updated: 2025/12/16*

---

多年来，我们（Jeff & Sanjay）在各种代码的性能调优上做了大量工作。从 Google 成立之初起，提高软件性能就非常重要，因为这让我们能为更多用户做更多事情。编写本文是为了确定我们在进行此类工作时使用的一些通用原则和特定技术，并尝试挑选具有代表性的源代码更改（CL）作为各种方法和技术的示例。虽然下面的大多数具体建议参考了 C++ 类型和 CL，但通用原则也适用于其他语言。本文专注于单个二进制文件上下文中的通用性能调优，不涉及分布式系统或机器学习（ML）硬件性能调优。

## 思考性能的重要性

Knuth 经常被断章取义地引用为：*“过早优化是万恶之源”*。完整的引用是：*“在大约 97% 的时间里，我们应该忘记微小的效率：过早优化是万恶之源。但我们不应在关键的 3% 中放弃机会。”* 本文就是关于那关键的 3%。Knuth 还有一段更引人注目的名言：

> 从例 2 到例 2a 的速度提升只有大约 12%，许多人会认为这是微不足道的。当今许多软件工程师共有的传统智慧是忽略微小的效率；但我相信这只是对那些无法调试或维护其“优化”程序的因小失大的程序员所见所闻的过度反应。在成熟的工程学科中，容易获得的 12% 提升绝不会被认为是边缘性的；我相信同样的观点也应该在软件工程中盛行。当然，对于一次性工作，我不会费心进行此类优化，但在准备高质量程序时，我不想限制自己使用拒绝我获得此类效率的工具。

许多人会说“让我们先以尽可能简单的方式写代码，以后再通过分析（profile）来处理性能问题”。然而，这种方法往往是错误的：

1. 如果你在开发大型系统时忽略所有性能问题，最终会得到一个“平坦”的分析结果（flat profile），没有任何明显的瓶颈，因为性能损失遍布各处。很难弄清楚如何开始改进性能。
2. 如果你正在开发一个供他人使用的库，遇到性能问题的人往往是那些无法轻易做出性能改进的人（他们必须理解他人编写的代码细节，并就性能优化的重要性进行协商）。
3. 当系统处于重载使用时，更难做出重大更改。
4. 也很难判断是否存在可以轻松解决的性能问题，因此我们最终可能会采用昂贵的解决方案，如过度复制或严重过度配置服务来处理负载问题。

相反，我们建议在编写代码时，如果不会显著影响代码的可读性/复杂性，请尝试选择更快的替代方案。

## 估算 (Estimation)

如果你能对所写代码中性能的重要性产生直觉，你就能做出更明智的决定。

*   **是测试代码吗？** 主要是算法和数据结构的渐近复杂度。
*   **是特定应用的吗？** 判断代码是在初始化/设置路径上，还是在热路径（如处理每个请求）上。
*   **是库代码吗？** 这通常难以预料，因此遵循简单的技巧（如使用 `absl::InlinedVector` 代替 `std::vector`）非常重要。

利用“信封背面计算”（back of the envelope calculations）可以快速排除掉一些方案。以下是一些基础操作的大致成本（2025 年更新）：

| 操作 | 延迟 |
| :--- | :--- |
| L1 cache reference | 0.5 ns |
| L2 cache reference | 3 ns |
| Branch mispredict | 5 ns |
| Mutex lock/unlock (uncontended) | 15 ns |
| Main memory reference | 50 ns |
| Compress 1K bytes with Snappy | 1,000 ns |
| Read 4KB from SSD | 20,000 ns |
| Round trip within same datacenter | 50,000 ns |
| Read 1MB sequentially from memory | 64,000 ns |
| Read 1MB from SSD | 1,000,000 ns |
| Disk seek | 5,000,000 ns |
| Read 1MB sequentially from disk | 10,000,000 ns |

## 测量 (Measurement)

在开始改进之前，或者当面临涉及性能、简洁性等的权衡时，你需要测量或估算潜在的性能收益。

### 分析工具与建议

*   **pprof:** 首选工具，提供高水平的性能信息。
*   **perf:** 用于更深入的洞察。
*   **Microbenchmark:** 定反馈周期。
*   **锁竞争:** 检查是否因为锁竞争导致 CPU 使用率偏低。

### 当分析结果是“平坦”时该怎么办

如果 CPU profile 没有明显的性能瓶颈（低垂的果实已被摘完）：

1.  **不要小看许多微小的优化。** 二十个 1% 的改进集合起来就是巨大的提升。
2.  **寻找调用栈顶部的循环。** 重构这些循环或其调用的代码。
3.  **寻找过于通用的代码。** 用定制化或底层实现替换（如用前缀匹配替换正则）。
4.  **减少分配。** 获取内存分配分析（allocation profile），减少分配数量可以减少分配器时间和缓存缺失。

## API 考量

尝试将性能改进组织在封装边界内，而不影响公共接口。

### 批量 API (Bulk APIs)

提供批量操作以减少昂贵的 API 边界交叉或利用算法改进。
*   **例如：** `LookupMany` 代替多次 `Lookup`；`DeleteRefs` 代替多次 `DeleteRef` 以摊销锁开销。

### 视图类型 (View types)

优先使用视图类型（如 `std::string_view`, `std::span<T>`, `absl::FunctionRef`）作为函数参数，以减少拷贝并允许调用者选择自己的容器类型。

### 预分配/预计算参数

对于频繁调用的例程，允许调用者传入预分配的数据结构或预计算的信息。

## 算法改进

这是性能提升最关键的机会（例如将 $O(N^2)$ 改为 $O(N \log N)$）。

*   **例子：** 使用 Floyd 堆构建算法（$O(N)$ 而不是 $O(N \log N)$）。
*   **例子：** 将 `IntervalMap` 替换为哈希表（$O(1)$ 查询）。

## 更好的内存表示

精心设计的内存布局可以避免昂贵的缓存缺失并减少总线流量。

*   **紧凑的数据结构：** 减少内存占用，减少缓存行触碰。
*   **内存布局优化：** 重新排列字段顺序以减少填充（padding）；将热的数据放在一起，冷的数据分开。
*   **索引代替指针：** 在 64 位机器上指针占 8 字节，使用 32 位整型索引可以显著减小尺寸并提高局部性。
*   **内联存储 (Inlined storage)：** 对元素较少的场景使用 `InlinedVector`。
*   **避免过度嵌套的 Map：** 将嵌套 Map 替换为复合键的单级 Map。

## 减少内存分配

内存分配会增加分配器时间、初始化/销毁成本，并导致数据分散。

*   **避免不必要的分配：** 使用静态分配的对象或栈分配（前提是生命周期受限）。
*   **预设容量：** 使用 `reserve()` 避免多次重新分配。
*   **避免拷贝：** 优先使用移动（move）或存储指针/索引。
*   **重用临时对象：** 将变量定义移出循环外。

## 避免不必要的工作

*   **公共情况的快速路径：** 为最常见的简单情况编写专门的代码路径。
*   **预计算：** 对昂贵的信息只计算一次。
*   **延迟计算：** 直到真正需要时才进行昂贵的计算。
*   **特殊化代码：** 用简单的字符串操作代替正则表达式。
*   **缓存：** 避免重复工作。
*   **减少统计开销：** 并非所有统计都必须是实时的，可以采样。
*   **减少日志开销：** 即使是未打印的日志（VLOG）也有开销，在热路径上考虑移除或预判断开关。

## 代码体积考量

大的代码体积会增加编译时间、指令缓存压力和分支预测开销。

*   **精简内联代码：** 避免在内联函数中进行复杂的错误处理，将其移至非内联函数中。
*   **谨慎内联：** 不是越内联越快。
*   **减少模板实例化：** 避免为每种组合都生成一份代码，可以将不依赖模板的部分提取到基类。

## 并行化与同步

*   **利用并行性：** 现代机器核心很多，但要注意内存带宽瓶颈。
*   **摊销锁开销：** 避免细粒度锁。
*   **保持临界区短。**
*   **分片 (Sharding) 减少竞争：** 将数据结构拆分为多个独立的部分，每部分有自己的锁。
*   **SIMD 指令。**
*   **减少伪共享 (False sharing)：** 使用 `alignas` 将不同线程频繁修改的变量隔离开。

## Protocol Buffer 建议

Protobuf 很方便，但成本很高。将 1000 个点的处理从 Protobuf 改为 C++ struct 的 `std::vector`，性能可能提升 **20 倍**。

*   **不要过度使用。**
*   **避免不必要的层级。**
*   **为常用字段使用小字段编号（1-15）。**
*   **考虑使用 `VIEW` (aliasing) 避免大字符串拷贝。**
*   **使用 Arena 分配。**
*   **避免 Protobuf Map。**

## C++ 特定建议

*   **容器：** 优先使用 `absl::flat_hash_map` 代替 `std::unordered_map`；使用 `absl::btree_map` 代替 `std::map`。
*   **Small Vector：** 使用 `absl::InlinedVector`。
*   **Status 开销：** `absl::StatusOr` 在热路径上有非零开销，避免在每秒调用数百万次的函数中使用。
